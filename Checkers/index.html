<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Checkers</title>
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #2c2c2c;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
        }

        .game-container {
            max-width: 500px;
            width: 100%;
            background-color: #1e1e1e;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .board-container {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1 / 1;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 2px solid #5a5a5a;
            border-radius: 0.75rem;
            overflow: hidden;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .cell {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .cell.light {
            background-color: #f0d2b0;
        }

        .cell.dark {
            background-color: #8c634a;
        }

        .cell.highlight {
            background-color: #5cb85c;
            cursor: pointer;
        }

        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            cursor: pointer;
            position: relative;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s ease-in-out;
        }

        .piece.black {
            background-color: #1a1a1a;
            border: 2px solid #5a5a5a;
        }

        .piece.red {
            background-color: #e53e3e;
            border: 2px solid #ff7b7b;
        }

        .piece.king::after {
            content: '\f051'; /* Crown icon from Font Awesome */
            font-family: 'Font Awesome 5 Free';
            font-weight: 900;
            color: gold;
            font-size: 0.7em;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-shadow: 0 0 5px #000;
        }

        .piece.selected {
            transform: scale(1.15);
            border: 3px solid #5cb85c;
            z-index: 10;
        }

        .new-game-btn {
            background-color: #3b3b3b;
            color: #e0e0e0;
            font-weight: bold;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 9999px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .new-game-btn:hover {
            background-color: #4b4b4b;
            transform: translateY(-2px);
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #3b3b3b;
            border-radius: 1rem;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7);
            z-index: 20;
            width: 80%;
            max-width: 400px;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 15;
            border-radius: 1.5rem;
        }
    </style>
</head>
<body class="bg-gray-800 flex items-center justify-center min-h-screen p-4">
    <div class="game-container">
        <h1 class="text-4xl font-bold mb-2 text-red-500">Checkers</h1>
        <p class="text-sm text-blue-400 mb-4 cursor-pointer hover:underline" onclick="showMessage('How to play: \n\n- Move your pieces diagonally forward one square.\n- Capture an opponent\'s piece by jumping over it diagonally.\n- You can make multiple jumps in a single turn.\n- When a piece reaches the last row of the opponent\'s side, it becomes a King.\n- Kings can move and capture both forward and backward.')">How to play?</p>

        <!-- Start Screen -->
        <div id="startScreen" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-700 p-8 rounded-2xl shadow-xl z-20 w-11/12 max-w-sm">
            <h2 class="text-2xl font-semibold mb-6 text-center text-white">Choose Game Mode</h2>
            <div class="flex flex-col space-y-4">
                <button id="playerVsPlayerBtn" class="py-4 px-6 rounded-xl bg-gray-600 text-white font-medium text-lg hover:bg-gray-500 transition-colors duration-200 shadow-md">Player vs Player</button>
                <button id="playerVsCPUBtn" class="py-4 px-6 rounded-xl bg-gray-600 text-white font-medium text-lg hover:bg-gray-500 transition-colors duration-200 shadow-md">Player vs CPU</button>
            </div>
        </div>

        <!-- Game Screen -->
        <div id="gameScreen" class="hidden w-full flex flex-col items-center">
            <div id="turn-indicator" class="text-xl font-bold mb-4 flex items-center">
                Turn: <span id="current-player-icon" class="w-4 h-4 ml-2 rounded-full"></span> <span id="current-player-text" class="ml-2">Black</span>
            </div>
            <div class="board-container"></div>
            <button id="new-game-btn" class="mt-8 new-game-btn">New Game</button>
        </div>

        <!-- Win/Error Message Box -->
        <div id="messageBox" class="message-box hidden">
            <p id="messageText" class="text-xl font-semibold mb-4"></p>
            <button id="closeMessageBtn" class="py-2 px-4 rounded-full bg-blue-500 text-white font-medium hover:bg-blue-600 transition-colors">OK</button>
        </div>
        <div id="messageOverlay" class="overlay hidden"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardContainer = document.querySelector('.board-container');
            const newGameBtn = document.getElementById('new-game-btn');
            const turnIndicatorIcon = document.getElementById('current-player-icon');
            const turnIndicatorText = document.getElementById('current-player-text');

            const startScreen = document.getElementById('startScreen');
            const gameScreen = document.getElementById('gameScreen');
            const playerVsPlayerBtn = document.getElementById('playerVsPlayerBtn');
            const playerVsCPUBtn = document.getElementById('playerVsCPUBtn');

            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const closeMessageBtn = document.getElementById('closeMessageBtn');
            const messageOverlay = document.getElementById('messageOverlay');

            const BOARD_SIZE = 8;
            let board = [];
            let currentPlayer = 'black';
            let selectedPiece = null;
            let capturedPieces = [];
            let gameMode = 'playerVsPlayer';
            let gameActive = false;

            /**
             * Initializes the game board with pieces in their starting positions.
             * The board is a 2D array where 0 is an empty square, 1 is a black piece,
             * 2 is a red piece, 3 is a black king, and 4 is a red king.
             */
            const createBoard = () => {
                board = [];
                for (let i = 0; i < BOARD_SIZE; i++) {
                    board[i] = [];
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (i < 3 && (i + j) % 2 !== 0) {
                            board[i][j] = 2; // Red piece (CPU)
                        } else if (i > 4 && (i + j) % 2 !== 0) {
                            board[i][j] = 1; // Black piece (User)
                        } else {
                            board[i][j] = 0; // Empty
                        }
                    }
                }
            };

            /**
             * Renders the game board and pieces on the screen.
             */
            const renderBoard = () => {
                boardContainer.innerHTML = '';
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        const cell = document.createElement('div');
                        cell.classList.add('cell');
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        if ((i + j) % 2 === 0) {
                            cell.classList.add('light');
                        } else {
                            cell.classList.add('dark');
                        }

                        if (board[i][j] !== 0) {
                            const piece = document.createElement('div');
                            piece.classList.add('piece');
                            piece.classList.add(board[i][j] % 2 !== 0 ? 'black' : 'red');
                            if (board[i][j] > 2) {
                                piece.classList.add('king');
                            }
                            cell.appendChild(piece);
                        }

                        boardContainer.appendChild(cell);
                    }
                }
                updateTurnIndicator();
            };

            /**
             * Updates the turn indicator display to show the current player.
             */
            const updateTurnIndicator = () => {
                turnIndicatorText.textContent = currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1);
                if (currentPlayer === 'black') {
                    turnIndicatorIcon.style.backgroundColor = '#1a1a1a';
                    turnIndicatorIcon.style.border = '2px solid #5a5a5a';
                } else {
                    turnIndicatorIcon.style.backgroundColor = '#e53e3e';
                    turnIndicatorIcon.style.border = '2px solid #ff7b7b';
                }
            };

            /**
             * Shows a message box with the given text.
             * @param {string} text - The message to display.
             */
            const showMessage = (text) => {
                messageText.textContent = text;
                messageBox.classList.remove('hidden');
                messageOverlay.classList.remove('hidden');
            };

            /**
             * Hides the message box.
             */
            const hideMessage = () => {
                messageBox.classList.add('hidden');
                messageOverlay.classList.add('hidden');
                if (gameActive) {
                    checkForWin();
                }
            };

            /**
             * Checks if a move is valid.
             * @param {number} startRow - The starting row of the piece.
             * @param {number} startCol - The starting column of the piece.
             * @param {number} endRow - The destination row.
             * @param {number} endCol - The destination column.
             * @returns {{isValid: boolean, isCapture: boolean, capturedPiece?: object}} - An object with move details.
             */
            const isValidMove = (startRow, startCol, endRow, endCol) => {
                const pieceType = board[startRow][startCol];
                const piecePlayer = pieceType % 2 !== 0 ? 'black' : 'red';

                if (piecePlayer !== currentPlayer) {
                    return { isValid: false };
                }
                if (board[endRow][endCol] !== 0) {
                    return { isValid: false };
                }

                const rowDiff = endRow - startRow;
                const colDiff = Math.abs(endCol - startCol);
                
                // Direction logic based on player
                const forward = (currentPlayer === 'black' && rowDiff < 0) || (currentPlayer === 'red' && rowDiff > 0);
                const isKing = pieceType > 2;
                const canMoveForward = forward || isKing;

                // Simple move
                if (colDiff === 1 && Math.abs(rowDiff) === 1 && canMoveForward) {
                    return { isValid: true, isCapture: false };
                }

                // Capture move
                if (colDiff === 2 && Math.abs(rowDiff) === 2 && canMoveForward) {
                    const capturedRow = startRow + rowDiff / 2;
                    const capturedCol = startCol + (endCol - startCol) / 2;
                    const capturedPieceType = board[capturedRow][capturedCol];

                    if (capturedPieceType !== 0 && (capturedPieceType % 2 !== 0) !== (piecePlayer === 'black')) {
                        return {
                            isValid: true,
                            isCapture: true,
                            capturedPiece: { row: capturedRow, col: capturedCol }
                        };
                    }
                }
                return { isValid: false };
            };

            /**
             * Makes a move on the board and handles captures.
             * @param {number} startRow - The starting row.
             * @param {number} startCol - The starting column.
             * @param {number} endRow - The destination row.
             * @param {number} endCol - The destination column.
             * @param {object} moveInfo - The move information from isValidMove.
             */
            const makeMove = (startRow, startCol, endRow, endCol, moveInfo) => {
                board[endRow][endCol] = board[startRow][startCol];
                board[startRow][startCol] = 0;

                if (moveInfo.isCapture) {
                    const { row, col } = moveInfo.capturedPiece;
                    capturedPieces.push(board[row][col]);
                    board[row][col] = 0;
                }

                // Check for king
                if ((currentPlayer === 'black' && endRow === 0) || (currentPlayer === 'red' && endRow === BOARD_SIZE - 1)) {
                    board[endRow][endCol] += 2; // Convert to king
                }
            };

            /**
             * Checks for available captures for the current player.
             * @returns {boolean} - True if a capture is available.
             */
            const canCapture = (player = currentPlayer) => {
                const isBlack = player === 'black';
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        const pieceType = board[i][j];
                        if (pieceType !== 0 && (pieceType % 2 !== 0) === isBlack) {
                            // Check all possible capture moves for this piece
                            const directions = pieceType > 2 ? [-1, 1] : isBlack ? [-1] : [1];
                            for (const dRow of directions) {
                                for (const dCol of [-1, 1]) {
                                    const jumpRow = i + dRow * 2;
                                    const jumpCol = j + dCol * 2;
                                    if (jumpRow >= 0 && jumpRow < BOARD_SIZE && jumpCol >= 0 && jumpCol < BOARD_SIZE) {
                                        const originalPlayer = currentPlayer;
                                        currentPlayer = player;
                                        const canCaptureThisPiece = isValidMove(i, j, jumpRow, jumpCol);
                                        currentPlayer = originalPlayer;
                                        if (canCaptureThisPiece.isValid && canCaptureThisPiece.isCapture) {
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return false;
            };

            /**
             * Handles a click on a cell of the board.
             * @param {Event} event - The click event.
             */
            const handleClick = (event) => {
                if (!gameActive) return;

                const clickedCell = event.target.closest('.cell');
                if (!clickedCell) return;

                const row = parseInt(clickedCell.dataset.row);
                const col = parseInt(clickedCell.dataset.col);

                if (selectedPiece) {
                    const moveInfo = isValidMove(selectedPiece.row, selectedPiece.col, row, col);
                    if (moveInfo.isValid) {
                        const hasMandatoryCaptures = canCapture();
                        const isCaptureMove = moveInfo.isCapture;

                        if (hasMandatoryCaptures && !isCaptureMove) {
                            showMessage("You must make a capture move if available.");
                            return;
                        }

                        makeMove(selectedPiece.row, selectedPiece.col, row, col, moveInfo);
                        
                        // Check for multi-jump
                        if (isCaptureMove) {
                            const newCaptures = checkForMultiJump(row, col);
                            if (newCaptures.length > 0) {
                                selectedPiece = { row, col };
                                renderBoard();
                                document.querySelector(`[data-row="${row}"][data-col="${col}"]`).querySelector('.piece').classList.add('selected');
                                highlightPossibleMoves(row, col);
                                return;
                            }
                        }
                        
                        // Switch turn
                        currentPlayer = currentPlayer === 'black' ? 'red' : 'black';
                        selectedPiece = null;
                        renderBoard();
                        checkForWin();
                        if (gameMode === 'playerVsCPU' && currentPlayer === 'red') {
                            gameActive = false;
                            setTimeout(() => {
                                handleCPUMove();
                                gameActive = true;
                            }, 1000);
                        }
                    } else {
                        // Invalid move, clear selection
                        selectedPiece = null;
                        renderBoard();
                    }
                } else {
                    const pieceType = board[row][col];
                    if (pieceType !== 0 && (pieceType % 2 !== 0) === (currentPlayer === 'black')) {
                        selectedPiece = { row, col };
                        renderBoard();
                        document.querySelector(`[data-row="${row}"][data-col="${col}"]`).querySelector('.piece').classList.add('selected');
                        highlightPossibleMoves(row, col);
                    }
                }
            };
            
            /**
             * Checks if a multi-jump is possible from the given position.
             * @param {number} row - The row of the piece.
             * @param {number} col - The column of the piece.
             * @returns {Array<object>} - An array of possible capture moves.
             */
            const checkForMultiJump = (row, col) => {
                const possibleJumps = [];
                const directions = board[row][col] > 2 ? [-1, 1] : currentPlayer === 'black' ? [-1] : [1];
                for (const dRow of directions) {
                    for (const dCol of [-1, 1]) {
                        const jumpRow = row + dRow * 2;
                        const jumpCol = col + dCol * 2;
                        if (jumpRow >= 0 && jumpRow < BOARD_SIZE && jumpCol >= 0 && jumpCol < BOARD_SIZE) {
                            const moveInfo = isValidMove(row, col, jumpRow, jumpCol);
                            if (moveInfo.isValid && moveInfo.isCapture) {
                                possibleJumps.push({row: jumpRow, col: jumpCol});
                            }
                        }
                    }
                }
                return possibleJumps;
            };

            /**
             * Highlights all valid moves for a selected piece.
             * @param {number} row - The row of the selected piece.
             * @param {number} col - The column of the selected piece.
             */
            const highlightPossibleMoves = (row, col) => {
                const cells = document.querySelectorAll('.cell');
                cells.forEach(cell => cell.classList.remove('highlight'));
                
                const hasMandatoryCaptures = canCapture();

                const directions = board[row][col] > 2 ? [-1, 1] : currentPlayer === 'black' ? [-1] : [1];
                
                for (const dRow of directions) {
                    for (const dCol of [-1, 1]) {
                        // Check for simple moves
                        const endRow = row + dRow;
                        const endCol = col + dCol;
                        if (endRow >= 0 && endRow < BOARD_SIZE && endCol >= 0 && endCol < BOARD_SIZE) {
                            const moveInfo = isValidMove(row, col, endRow, endCol);
                            if (moveInfo.isValid && !hasMandatoryCaptures) {
                                document.querySelector(`[data-row="${endRow}"][data-col="${endCol}"]`).classList.add('highlight');
                            }
                        }
                        // Check for capture moves
                        const jumpRow = row + dRow * 2;
                        const jumpCol = col + dCol * 2;
                        if (jumpRow >= 0 && jumpRow < BOARD_SIZE && jumpCol >= 0 && jumpCol < BOARD_SIZE) {
                            const moveInfo = isValidMove(row, col, jumpRow, jumpCol);
                            if (moveInfo.isValid && moveInfo.isCapture) {
                                document.querySelector(`[data-row="${jumpRow}"][data-col="${jumpCol}"]`).classList.add('highlight');
                            }
                        }
                    }
                }
            };
            
            /**
             * Implements the CPU's move logic (simple greedy AI).
             */
            const handleCPUMove = () => {
                const cpuPlayer = 'red';
                const allPossibleMoves = [];

                // Find all possible moves for the CPU
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        const pieceType = board[i][j];
                        // Check if the piece belongs to the CPU
                        if (pieceType !== 0 && (pieceType % 2 !== 0) === (cpuPlayer === 'black')) {
                             // Corrected direction logic for red pieces
                            const directions = pieceType > 2 ? [-1, 1] : [1]; 
                            for (const dRow of directions) {
                                for (const dCol of [-1, 1]) {
                                    const endRow = i + dRow;
                                    const endCol = j + dCol;

                                    // Check simple move
                                    if (endRow >= 0 && endRow < BOARD_SIZE && endCol >= 0 && endCol < BOARD_SIZE) {
                                        // Temporarily set current player to CPU to use isValidMove
                                        const originalPlayer = currentPlayer;
                                        currentPlayer = cpuPlayer;
                                        const moveInfo = isValidMove(i, j, endRow, endCol);
                                        currentPlayer = originalPlayer;

                                        if (moveInfo.isValid) {
                                            allPossibleMoves.push({ startRow: i, startCol: j, endRow, endCol, moveInfo });
                                        }
                                    }

                                    // Check capture move
                                    const jumpRow = i + dRow * 2;
                                    const jumpCol = j + dCol * 2;
                                    if (jumpRow >= 0 && jumpRow < BOARD_SIZE && jumpCol >= 0 && jumpCol < BOARD_SIZE) {
                                        // Temporarily set current player to CPU to use isValidMove
                                        const originalPlayer = currentPlayer;
                                        currentPlayer = cpuPlayer;
                                        const moveInfo = isValidMove(i, j, jumpRow, jumpCol);
                                        currentPlayer = originalPlayer;

                                        if (moveInfo.isValid && moveInfo.isCapture) {
                                            allPossibleMoves.push({ startRow: i, startCol: j, endRow: jumpRow, endCol: jumpCol, moveInfo });
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                const captureMoves = allPossibleMoves.filter(move => move.moveInfo.isCapture);
                let move;

                if (captureMoves.length > 0) {
                    // Prioritize captures
                    move = captureMoves[Math.floor(Math.random() * captureMoves.length)];
                } else if (allPossibleMoves.length > 0) {
                    // Or make a random valid move
                    move = allPossibleMoves[Math.floor(Math.random() * allPossibleMoves.length)];
                }

                if (move) {
                    currentPlayer = cpuPlayer; // Set current player to CPU for makeMove
                    makeMove(move.startRow, move.startCol, move.endRow, move.endCol, move.moveInfo);
                    
                    let multiJumpPossible = false;
                    if(move.moveInfo.isCapture) {
                        const newCaptures = checkForMultiJump(move.endRow, move.endCol);
                        if (newCaptures.length > 0) {
                            multiJumpPossible = true;
                            // Make the next capture move in the chain
                            const nextJump = newCaptures[Math.floor(Math.random() * newCaptures.length)];
                            handleCPUMoveRecursive(move.endRow, move.endCol, nextJump.row, nextJump.col);
                        }
                    }

                    if (!multiJumpPossible) {
                        currentPlayer = 'black';
                        renderBoard();
                        checkForWin();
                    }
                } else {
                    showMessage("Black Player Wins! CPU has no moves left.");
                }
            };
            
            /**
             * Recursive function to handle multi-jump logic for the CPU.
             * @param {number} startRow - The starting row of the jump chain.
             * @param {number} startCol - The starting column of the jump chain.
             * @param {number} endRow - The destination row for the current jump.
             * @param {number} endCol - The destination column for the current jump.
             */
            const handleCPUMoveRecursive = (startRow, startCol, endRow, endCol) => {
                const moveInfo = isValidMove(startRow, startCol, endRow, endCol);
                makeMove(startRow, startCol, endRow, endCol, moveInfo);
                renderBoard();

                const newCaptures = checkForMultiJump(endRow, endCol);
                if (newCaptures.length > 0) {
                    const nextJump = newCaptures[Math.floor(Math.random() * newCaptures.length)];
                    setTimeout(() => handleCPUMoveRecursive(endRow, endCol, nextJump.row, nextJump.col), 500);
                } else {
                    currentPlayer = 'black';
                    renderBoard();
                    checkForWin();
                }
            };

            /**
             * Checks for a winner.
             */
            const checkForWin = () => {
                let blackPieces = 0;
                let redPieces = 0;
                for (let i = 0; i < BOARD_SIZE; i++) {
                    for (let j = 0; j < BOARD_SIZE; j++) {
                        if (board[i][j] === 1 || board[i][j] === 3) blackPieces++;
                        if (board[i][j] === 2 || board[i][j] === 4) redPieces++;
                    }
                }
                if (blackPieces === 0) {
                    gameActive = false;
                    showMessage("Red Player Wins!");
                } else if (redPieces === 0) {
                    gameActive = false;
                    showMessage("Black Player Wins!");
                }
            };
            
            /**
             * Resets the game to its initial state.
             */
            const resetGame = () => {
                gameActive = true;
                currentPlayer = 'black';
                selectedPiece = null;
                capturedPieces = [];
                createBoard();
                renderBoard();
            };

            // Event Listeners
            boardContainer.addEventListener('click', handleClick);
            newGameBtn.addEventListener('click', resetGame);
            closeMessageBtn.addEventListener('click', hideMessage);

            playerVsPlayerBtn.addEventListener('click', () => {
                gameMode = 'playerVsPlayer';
                startScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                resetGame();
            });

            playerVsCPUBtn.addEventListener('click', () => {
                gameMode = 'playerVsCPU';
                startScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                resetGame();
            });
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ludo Game</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }

        .board-container {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            width: 80vmin; /* Responsive sizing */
            height: 80vmin;
            max-width: 600px;
            max-height: 600px;
            margin: auto;
            border: 4px solid #333;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            position: relative;
        }

        .square {
            border: 1px solid #ccc;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* New home base container for a more accurate representation */
        .home-base-container {
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid #333;
            border-radius: 10px;
        }

        .start-home-base {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 5px;
            padding: 10px;
            background-color: white;
            border-radius: 10px;
            width: 80%;
            height: 80%;
        }

        .token-base {
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid #333;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; /* Make token-base the positioning parent for the token */
        }

        .token {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            cursor: pointer;
            border: 2px solid #000;
            transition: transform 0.2s ease-in-out;
            position: absolute; /* Tokens are positioned absolutely within the token-base */
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .token:hover, .token.movable {
            transform: scale(1.1) translate(-50%, -50%);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1.1) translate(-50%, -50%); }
            50% { transform: scale(1.2) translate(-50%, -50%); }
            100% { transform: scale(1.1) translate(-50%, -50%); }
        }

        /* Player Colors */
        .yellow { background-color: #fcdc3d; }
        .green { background-color: #2ab866; }
        .red { background-color: #e54646; }
        .blue { background-color: #2d88d2; }

        /* Board path colors */
        .yellow-path { background-color: #ffef96; }
        .green-path { background-color: #8fe5b4; }
        .red-path { background-color: #f7a9a9; }
        .blue-path { background-color: #8cb8e7; }
        .white-path { background-color: #fff; }

        /* Safe Squares */
        .safe {
            position: relative;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"><g><path d="M 0 0 L 100 50 L 0 100 L 0 0" fill="rgba(0,0,0,0.15)"/><path d="M 100 0 L 0 50 L 100 100 L 100 0" fill="rgba(0,0,0,0.15)"/></g></svg>');
        }
        .yellow.safe { background-color: #fcdc3d; }
        .green.safe { background-color: #2ab866; }
        .red.safe { background-color: #e54646; }
        .blue.safe { background-color: #2d88d2; }

        .center-triangle-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: white;
            border: 2px solid #333;
        }
        
        .center-triangle {
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
        }

        .yellow-triangle { border-width: 0 0 7.5vmin 7.5vmin; border-color: transparent transparent #fcdc3d transparent; top: 0; left: 0; }
        .blue-triangle { border-width: 7.5vmin 0 0 7.5vmin; border-color: #2d88d2 transparent transparent transparent; bottom: 0; right: 0; }
        .red-triangle { border-width: 0 7.5vmin 7.5vmin 0; border-color: transparent #e54646 transparent transparent; top: 0; right: 0; }
        .green-triangle { border-width: 7.5vmin 7.5vmin 0 0; border-color: #2ab866 transparent transparent transparent; bottom: 0; left: 0; }

        .dice-container {
            width: 60px;
            height: 60px;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 5px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }

        .dot {
            width: 10px;
            height: 10px;
            background-color: #333;
            border-radius: 50%;
            place-self: center;
        }

        .dice-1 { grid-column: 2; grid-row: 2; }
        .dice-2 { grid-column: 1; grid-row: 1; }
        .dice-3 { grid-column: 3; grid-row: 3; }
        .dice-4 { grid-column: 1; grid-row: 1; }
        .dice-5 { grid-column: 3; grid-row: 3; }
        .dice-6 { grid-column: 1; grid-row: 2; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4">
    <h1 class="text-4xl font-bold text-gray-800 mb-6">Ludo</h1>
    <div class="flex flex-col items-center gap-6">
        <div id="status-message" class="bg-white p-4 rounded-xl shadow-md text-center font-semibold text-gray-700">
            Click "Roll Dice" to start the game!
        </div>
        <div class="board-container bg-white">
            <!-- The board squares will be generated here by JavaScript -->
        </div>

        <div class="flex items-center gap-8 mt-6">
            <button id="roll-dice-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transition-all duration-300 transform hover:scale-105 active:scale-95">
                Roll Dice
            </button>
            <div id="dice-display" class="dice-container hidden">
                <!-- Dice dots will be generated here by JavaScript -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const boardContainer = document.querySelector('.board-container');
            const rollDiceBtn = document.getElementById('roll-dice-btn');
            const diceDisplay = document.getElementById('dice-display');
            const statusMessage = document.getElementById('status-message');

            const boardSize = 15;
            const playerColors = ['red', 'blue', 'green', 'yellow'];
            let gameState = {
                players: playerColors.map(color => ({
                    color: color,
                    tokens: [
                        { id: `${color}-1`, position: -1, isHome: false, isWinner: false },
                        { id: `${color}-2`, position: -1, isHome: false, isWinner: false },
                        { id: `${color}-3`, position: -1, isHome: false, isWinner: false },
                        { id: `${color}-4`, position: -1, isHome: false, isWinner: false }
                    ],
                    startSquareIndex: 0,
                    homePathStartIndex: 0,
                    tokensInHome: 0,
                    consecutiveSixes: 0 // Track consecutive sixes for the new rule
                })),
                currentPlayerIndex: 0,
                diceValue: 0,
                movableTokens: [],
                turnPhase: 'roll', // 'roll' or 'move'
                
                // This is a single, continuous path for all players.
                // Each player will start at a different point on this path.
                mainPath: [100, 115, 130, 145, 160, 175, 174, 173, 172, 171, 170, 155, 140, 125, 110, 95, 94, 93, 92, 91, 76, 75, 74, 59, 58, 57, 56, 55, 40, 25, 26, 27, 28, 29, 30, 45, 60, 61, 62, 63, 64, 65, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 105],
                
                // Home paths for each player
                homePaths: {
                    red: [106, 107, 108, 109, 110, 111],
                    blue: [89, 88, 87, 86, 85, 84],
                    green: [80, 81, 82, 83, 84, 85],
                    yellow: [92, 93, 94, 95, 96, 97],
                },

                // Player-specific start and home path mappings
                playerStartIndices: {
                    red: 0,
                    blue: 13,
                    green: 26,
                    yellow: 39,
                },

                // Safe squares, defined by their grid indices, based on standard Ludo rules
                safeSquares: [100, 104, 105, 101, 172, 145, 28, 60],
            };

            const diceDotPatterns = {
                1: [5],
                2: [1, 9],
                3: [1, 5, 9],
                4: [1, 3, 7, 9],
                5: [1, 3, 5, 7, 9],
                6: [1, 3, 4, 6, 7, 9],
            };
            
            // Map the player color to the corresponding home path and start index
            gameState.players.forEach(player => {
                player.startSquareIndex = gameState.playerStartIndices[player.color];
            });

            // Setup the board in the DOM
            function renderBoard() {
                boardContainer.innerHTML = '';
                
                // Create the four large home base containers
                const yellowHome = document.createElement('div');
                yellowHome.className = 'home-base-container yellow';
                yellowHome.style.gridArea = '1 / 1 / 7 / 7';
                yellowHome.innerHTML = `
                    <div class="start-home-base">
                        <div class="token-base" id="base-yellow-1"></div>
                        <div class="token-base" id="base-yellow-2"></div>
                        <div class="token-base" id="base-yellow-3"></div>
                        <div class="token-base" id="base-yellow-4"></div>
                    </div>
                `;
                boardContainer.appendChild(yellowHome);

                const greenHome = document.createElement('div');
                greenHome.className = 'home-base-container green';
                greenHome.style.gridArea = '1 / 10 / 7 / 16';
                greenHome.innerHTML = `
                    <div class="start-home-base">
                        <div class="token-base" id="base-green-1"></div>
                        <div class="token-base" id="base-green-2"></div>
                        <div class="token-base" id="base-green-3"></div>
                        <div class="token-base" id="base-green-4"></div>
                    </div>
                `;
                boardContainer.appendChild(greenHome);

                const redHome = document.createElement('div');
                redHome.className = 'home-base-container red';
                redHome.style.gridArea = '10 / 1 / 16 / 7';
                redHome.innerHTML = `
                    <div class="start-home-base">
                        <div class="token-base" id="base-red-1"></div>
                        <div class="token-base" id="base-red-2"></div>
                        <div class="token-base" id="base-red-3"></div>
                        <div class="token-base" id="base-red-4"></div>
                    </div>
                `;
                boardContainer.appendChild(redHome);
                
                const blueHome = document.createElement('div');
                blueHome.className = 'home-base-container blue';
                blueHome.style.gridArea = '10 / 10 / 16 / 16';
                blueHome.innerHTML = `
                    <div class="start-home-base">
                        <div class="token-base" id="base-blue-1"></div>
                        <div class="token-base" id="base-blue-2"></div>
                        <div class="token-base" id="base-blue-3"></div>
                        <div class="token-base" id="base-blue-4"></div>
                    </div>
                `;
                boardContainer.appendChild(blueHome);

                // Create the center triangle area
                const centerTriangleContainer = document.createElement('div');
                centerTriangleContainer.className = 'center-triangle-container';
                centerTriangleContainer.style.gridArea = '7 / 7 / 10 / 10';
                centerTriangleContainer.innerHTML = `
                    <div class="center-triangle yellow-triangle"></div>
                    <div class="center-triangle red-triangle"></div>
                    <div class="center-triangle green-triangle"></div>
                    <div class="center-triangle blue-triangle"></div>
                `;
                boardContainer.appendChild(centerTriangleContainer);

                // Now, render the path squares.
                for (let i = 0; i < boardSize * boardSize; i++) {
                    const row = Math.floor(i / boardSize);
                    const col = i % boardSize;
                    
                    const isHomeBaseArea = (row < 6 && col < 6) || (row < 6 && col > 8) || (row > 8 && col < 6) || (row > 8 && col > 8);
                    const isCenterArea = (row >= 6 && row <= 8) && (col >= 6 && col <= 8);

                    if (!isHomeBaseArea && !isCenterArea) {
                        const square = document.createElement('div');
                        square.classList.add('square');
                        square.dataset.index = i;

                        // Add path color
                        if (isPathSquare(row, col)) {
                           square.classList.add('white-path');
                        }

                        // Add color to home path squares for visual distinction
                        if (i >= 96 && i <= 101) square.classList.add('red-path'); // Red home path
                        if (i >= 84 && i <= 89) square.classList.add('blue-path'); // Blue home path
                        if (i >= 80 && i <= 85) square.classList.add('green-path'); // Green home path
                        if (i >= 92 && i <= 97) square.classList.add('yellow-path'); // Yellow home path

                        // Add safe square indicators
                        if (gameState.safeSquares.includes(i)) {
                            square.classList.add('safe');
                        }

                        boardContainer.appendChild(square);
                    }
                }
            }

            // A helper function to determine if a square is part of the main path or home paths
            function isPathSquare(row, col) {
                return (row === 6 || row === 8 || col === 6 || col === 8) || // Main paths
                       ((row === 7 && col >= 1 && col <= 5) || (row === 7 && col >= 9 && col <= 13)) || // Home paths horizontal
                       ((col === 7 && row >= 1 && row <= 5) || (col === 7 && row >= 9 && row <= 13)); // Home paths vertical
            }
            
            function renderTokens() {
                // Clear existing tokens
                document.querySelectorAll('.token').forEach(token => token.remove());

                gameState.players.forEach(player => {
                    player.tokens.forEach(token => {
                        const tokenElement = document.createElement('div');
                        tokenElement.classList.add('token', player.color, 'shadow-md');
                        tokenElement.id = token.id; // Set ID for easier access
                        tokenElement.dataset.playerId = player.color;
                        tokenElement.dataset.tokenId = token.id;
                        tokenElement.textContent = token.id.split('-')[1];

                        // Add click listeners to tokens
                        tokenElement.addEventListener('click', () => handleTokenClick(token));

                        if (token.position === -1) {
                            // Token is in the home base
                            const baseElement = document.getElementById(`base-${player.color}-${token.id.split('-')[1]}`);
                            if (baseElement) {
                                baseElement.appendChild(tokenElement);
                            }
                        } else {
                            // Token is on the path
                            // The token's position is an index in the player's unique path
                            const playerPath = getPlayerPath(player.color);
                            const squareGridIndex = playerPath[token.position];
                            const squareElement = boardContainer.querySelector(`[data-index="${squareGridIndex}"]`);
                            if (squareElement) {
                                squareElement.appendChild(tokenElement);
                            }
                        }
                    });
                });
            }

            // A helper function to create a player's full path (main path + home path)
            function getPlayerPath(color) {
                const mainPath = gameState.mainPath;
                const homePath = gameState.homePaths[color];
                const playerStartIndex = gameState.playerStartIndices[color];
                
                const rotatedPath = [...mainPath.slice(playerStartIndex), ...mainPath.slice(0, playerStartIndex)];
                return [...rotatedPath, ...homePath];
            }

            function updateUI() {
                renderTokens();
                // Highlight current player's tokens
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                document.querySelectorAll(`.token`).forEach(token => {
                    token.classList.remove('movable', 'border-4', 'border-white');
                });
                
                // Show which tokens can be moved
                if (gameState.turnPhase === 'move') {
                    gameState.movableTokens.forEach(token => {
                        const tokenElement = document.getElementById(token.id);
                        if (tokenElement) {
                            tokenElement.classList.add('movable', 'border-4', 'border-white');
                        }
                    });
                }
                
                statusMessage.textContent = `It's ${currentPlayer.color.toUpperCase()}'s turn.`;

                // Update dice display
                diceDisplay.innerHTML = '';
                if (gameState.diceValue > 0) {
                    diceDisplay.classList.remove('hidden');
                    const dotLayout = {
                        1: [5], 2: [1, 9], 3: [1, 5, 9],
                        4: [1, 3, 7, 9], 5: [1, 3, 5, 7, 9],
                        6: [1, 3, 4, 6, 7, 9]
                    };
                    for (let i = 1; i <= 9; i++) {
                        const dotWrapper = document.createElement('div');
                        dotWrapper.classList.add('dot-wrapper', 'w-full', 'h-full', 'flex', 'items-center', 'justify-center');
                        if (dotLayout[gameState.diceValue].includes(i)) {
                            const dot = document.createElement('div');
                            dot.classList.add('dot');
                            dotWrapper.appendChild(dot);
                        }
                        diceDisplay.appendChild(dotWrapper);
                    }
                }
                
                // Disable/Enable the roll button
                rollDiceBtn.disabled = gameState.turnPhase === 'move';
                rollDiceBtn.classList.toggle('bg-gray-400', rollDiceBtn.disabled);
                rollDiceBtn.classList.toggle('hover:bg-indigo-700', !rollDiceBtn.disabled);
                rollDiceBtn.classList.toggle('cursor-not-allowed', rollDiceBtn.disabled);
            }

            function rollDice() {
                if (gameState.turnPhase !== 'roll') return;

                const diceRoll = Math.floor(Math.random() * 6) + 1;
                gameState.diceValue = diceRoll;
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                
                if (diceRoll === 6) {
                    currentPlayer.consecutiveSixes++;
                    if (currentPlayer.consecutiveSixes >= 3) {
                        statusMessage.textContent = `${currentPlayer.color.toUpperCase()} rolled three sixes in a row! Turn ends.`;
                        currentPlayer.consecutiveSixes = 0;
                        setTimeout(switchPlayer, 1500);
                        return;
                    }
                } else {
                    currentPlayer.consecutiveSixes = 0;
                }
                
                gameState.turnPhase = 'move';
                statusMessage.textContent = `${currentPlayer.color.toUpperCase()} rolled a ${diceRoll}.`;

                checkValidMoves();
                updateUI();
            }

            function checkValidMoves() {
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                gameState.movableTokens = [];

                // A token can be moved out of home only if a 6 is rolled and there is a token in home
                const hasTokensInHome = currentPlayer.tokens.some(token => token.position === -1);
                if (gameState.diceValue === 6 && hasTokensInHome) {
                    // If a 6 is rolled, any token can be moved, including those in home
                    gameState.movableTokens = currentPlayer.tokens.filter(token => !token.isWinner);
                } else {
                    // Otherwise, only tokens already on the board can move
                    gameState.movableTokens = currentPlayer.tokens.filter(token => token.position !== -1 && !token.isWinner);
                }

                if (gameState.movableTokens.length === 0) {
                    statusMessage.textContent += " No moves possible. Switching turn.";
                    setTimeout(switchPlayer, 1500);
                }
            }
            
            function handleTokenClick(token) {
                const currentPlayer = gameState.players[gameState.currentPlayerIndex];
                const clickedTokenPlayer = gameState.players.find(p => p.color === token.id.split('-')[0]);

                if (gameState.turnPhase !== 'move' || clickedTokenPlayer.color !== currentPlayer.color) {
                    statusMessage.textContent = "It's not your turn or you can't move that token.";
                    return;
                }
                
                const isMovable = gameState.movableTokens.some(t => t.id === token.id);

                if (isMovable) {
                    if (token.position === -1 && gameState.diceValue === 6) {
                        // Move token out of home base
                        token.position = currentPlayer.startSquareIndex;
                        statusMessage.textContent = `${currentPlayer.color.toUpperCase()} moved a token out of home base!`;
                        endMove();
                    } else if (token.position !== -1) {
                        // Move a token already on the board
                        const playerPath = getPlayerPath(currentPlayer.color);
                        const newPositionIndex = token.position + gameState.diceValue;
                        
                        // Check if the move is valid (not overshooting the home path)
                        if (newPositionIndex >= playerPath.length) {
                             statusMessage.textContent = "Cannot move, you overshot the final square!";
                             return;
                        }

                        // Check for capturing an opponent's token
                        const newGridIndex = playerPath[newPositionIndex];
                        const tokenToKill = findTokenAtPosition(newGridIndex);
                        
                        if (tokenToKill && tokenToKill.player.color !== currentPlayer.color) {
                            // Check if the square is a safe square
                            const isSafe = gameState.safeSquares.includes(newGridIndex);
                            if (!isSafe) {
                                // Kill the token
                                tokenToKill.token.position = -1;
                                statusMessage.textContent = `${currentPlayer.color.toUpperCase()} killed a ${tokenToKill.player.color.toUpperCase()} token!`;
                            }
                        }

                        // Move the token
                        token.position = newPositionIndex;

                        // Check for win condition
                        if (newPositionIndex === playerPath.length - 1) {
                            token.isWinner = true;
                            currentPlayer.tokensInHome++;
                            statusMessage.textContent = `${currentPlayer.color.toUpperCase()}'s token reached the end!`;
                            checkWinCondition(currentPlayer);
                        }
                        
                        endMove();
                    }
                } else {
                    statusMessage.textContent = "You can't move that token!";
                }
            }

            function endMove() {
                gameState.turnPhase = 'roll';
                // A dice roll of 6 gets another turn
                if (gameState.diceValue === 6) {
                    setTimeout(() => {
                        statusMessage.textContent = `${gameState.players[gameState.currentPlayerIndex].color.toUpperCase()} gets to roll again.`;
                        updateUI();
                    }, 1500);
                } else {
                    setTimeout(switchPlayer, 1500);
                }
                updateUI();
            }

            function findTokenAtPosition(gridIndex) {
                for (const player of gameState.players) {
                    for (const token of player.tokens) {
                        const playerPath = getPlayerPath(player.color);
                        if (token.position !== -1) {
                             const tokenGridIndex = playerPath[token.position];
                             if (tokenGridIndex === gridIndex) {
                                return { player, token };
                             }
                        }
                    }
                }
                return null;
            }

            function switchPlayer() {
                gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
                gameState.diceValue = 0;
                gameState.turnPhase = 'roll';
                updateUI();
            }

            function checkWinCondition(player) {
                if (player.tokensInHome === 4) {
                    statusMessage.textContent = `Game Over! ${player.color.toUpperCase()} wins!`;
                    rollDiceBtn.disabled = true;
                }
            }

            rollDiceBtn.addEventListener('click', rollDice);

            // Initial setup
            renderBoard();
            renderTokens();
            updateUI();
        });
    </script>
</body>
</html>
